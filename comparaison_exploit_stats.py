
# Quelques imports

import torch
import torch.nn as nn
import torchvision
from models.cnn import mnistConv
from matplotlib import pyplot as plt
import torch.nn.functional as F
import numpy as np
from scipy.special import softmax

from torch.optim import Adam

import pickle as pk
from scipy.stats import wasserstein_distance

stats = pk.load(open('stats/stats_linf_fine_dense_sharp.datsmall', 'rb'))
statsb = pk.load(open('stats/stats_linf_fine.dat', 'rb'))
name = "crossentropy-comparaison-dense-conv-fine"
name_1 = "Dense"
name_2 = "Conv"


def sliced_wasserstein(X, Y, num_proj):
    X = X.reshape((28,28))
    Y = Y.reshape((28,28))
    dim = 28
    ests = []
    for _ in range(num_proj):
        # sample uniformly from the unit sphere
        dir = np.random.rand(dim)
        dir /= np.linalg.norm(dir)

        # project the data
        X_proj = X @ dir
        Y_proj = Y @ dir

        # compute 1d wasserstein
        ests.append(wasserstein_distance(X_proj, Y_proj))
    return np.mean(ests)


def BC(p, q):
    s = 0
    p = torch.Tensor(p)
    q = torch.Tensor(q)

    return np.sqrt(1-torch.sqrt(p*q).sum().detach().cpu().numpy())


def BC_matrix(maplist):
    n = len(maplist)

    matrix = []
    for i in range(n):
        for j in range(n):
            if i == j:
                matrix.append(1)
            else:
                matrix.append(
                    BC(softmax(maplist[i].reshape(28 * 28), axis=0), softmax(maplist[j].reshape(28 * 28), axis=0)))

    return matrix

def wasserstein_matrix(maplist):
    n = len(maplist)

    matrix = []
    for i in range(n):
        for j in range(n):
            if i == j:
                matrix.append(1)
            else:
                matrix.append(
                    sliced_wasserstein(softmax(maplist[i].reshape(28 * 28), axis=0), softmax(maplist[j].reshape(28 * 28), axis=0), num_proj=10))

    return matrix

def xlogx(x):
    mask = (x > 1E-8).float()
    return (x * torch.log(x + 1E-7)) * mask


def entropy(X):
    X = torch.tensor(X)
    return - xlogx(X).sum().detach().cpu().numpy()

def entropy_list(maplist):
    n = len(maplist)

    matrix = []
    for i in range(n):
        matrix.append(entropy(softmax(maplist[i].reshape(28 * 28), axis=0)))

    return matrix




N = len(stats)
#adv_trains = [0.1, 0.5, 1., 1.5, 2., 5., 10., 20., 30., 50.]
adv_trains = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1., 1.2, 1.4, 1.6]
# adv_trains = [0.1, 1., 5., 10., 15., 20., 25., 30., 35., 40., 45., 50., 55., 60., 70., 80., 100.]

#attack_names = ["L2PGDAttack", "L1PGDAttack"]
attack_names = ["LinfPGDAttack"]
names = [f"{attack_name}_{str(adv)}" for adv in adv_trains for attack_name in attack_names ]

# for t in range(10):
#
#     for attack_name in attack_names:
#         fig, axs = plt.subplots(10, len(adv_trains), figsize=(10, 10))
#
#         for k, key in enumerate(adv_trains):
#             v = stats[f"{attack_name}_{str(key)}"]
#
#             for i in range(10):
#                 axs[i][k].imshow(v['proba_maps'][t][i].reshape(28, 28), cmap='gray')
#                 if i == 0:
#                     axs[i][k].set_title(key)
#                 axs[i][k].axis('off')
#         fig.tight_layout()
#
#         fig.savefig(f"tmp/proba_maps_samples_wholegen_dense_{attack_name}_{t}.png")


for attack_name in attack_names:

    params_data = np.zeros((6, len(adv_trains), 100))
    params_data_1 = np.zeros((6, len(adv_trains), 100))

    for k, adv in enumerate(adv_trains):
        print(k)
        v = stats[f"{attack_name}_{str(adv)}"]
        b = statsb[f"{attack_name}_{str(adv)}"]

        data = np.asarray(v['proba_maps']) # t, digit
        datab = np.asarray(b['proba_maps']) # t, digit

        for t in range(100):
            bc = BC_matrix(data[t])
            params_data[0, k, t] = np.asarray(bc).mean()
            params_data[1, k, t] = np.asarray(bc).min()

            ent = entropy_list(data[t])
            params_data[2, k, t] = np.asarray(ent).mean()
            params_data[3, k, t] = np.asarray(ent).max()

            wd2 = wasserstein_matrix(data[t])
            params_data[4, k, t] = np.asarray(wd2).mean()
            params_data[5, k, t] = np.asarray(wd2).min()
            
            bc = BC_matrix(datab[t])
            params_data_1[0, k, t] = np.asarray(bc).mean()
            params_data_1[1, k, t] = np.asarray(bc).min()

            ent = entropy_list(datab[t])
            params_data_1[2, k, t] = np.asarray(ent).mean()
            params_data_1[3, k, t] = np.asarray(ent).max()

            wd2 = wasserstein_matrix(datab[t])
            params_data_1[4, k, t] = np.asarray(wd2).mean()
            params_data_1[5, k, t] = np.asarray(wd2).min()

    stds = np.std(params_data[0], axis=1)
    means = np.mean(params_data[0], axis=1)

    stdsb = np.std(params_data_1[0], axis=1)
    meansb = np.mean(params_data_1[0], axis=1)

    mean_up = means + stds
    mean_down = means - stds

    mean_upb = meansb + stdsb
    mean_downb = meansb - stdsb

    plt.plot(adv_trains, means, color='blue')
    plt.plot(adv_trains, meansb, color='red')
    plt.fill_between(adv_trains, mean_up, mean_down, alpha=0.5, color='blue', label=f"{name_1}")
    plt.fill_between(adv_trains, mean_upb, mean_downb, alpha=0.5, color='red', label=f"{name_2}")

    plt.legend(loc="upper right")

    plt.xlabel("Ball sizes")
    plt.ylabel("Hellinger distance")

    plt.savefig(f"tmp/{attack_name}-{name}-bccorr.png")
    plt.clf()


    stds = np.std(params_data[1], axis=1)
    means = np.mean(params_data[1], axis=1)

    stdsb = np.std(params_data_1[1], axis=1)
    meansb = np.mean(params_data_1[1], axis=1)

    mean_up = means + stds
    mean_down = means - stds

    mean_upb = meansb + stdsb
    mean_downb = meansb - stdsb

    plt.plot(adv_trains, means, color='blue')
    plt.plot(adv_trains, meansb, color='red')
    plt.fill_between(adv_trains, mean_up, mean_down, alpha=0.5, color='blue', label=f"{name_1}")
    plt.fill_between(adv_trains, mean_upb, mean_downb, alpha=0.5, color='red', label=f"{name_2}")

    plt.legend(loc="upper right")

    plt.xlabel("Ball sizes")
    plt.ylabel("Hellinger distance")

    plt.savefig(f"tmp/{attack_name}-{name}-bccorr-min.png")
    plt.clf()

    # ========================================

    stds = np.std(params_data[2], axis=1)
    means = np.mean(params_data[2], axis=1)

    stdsb = np.std(params_data_1[2], axis=1)
    meansb = np.mean(params_data_1[2], axis=1)

    mean_up = means + stds
    mean_down = means - stds

    mean_upb = meansb + stdsb
    mean_downb = meansb - stdsb

    plt.plot(adv_trains, means, color='blue')
    plt.plot(adv_trains, meansb, color='red')
    plt.fill_between(adv_trains, mean_up, mean_down, alpha=0.5, color='blue', label=f"{name_1}")
    plt.fill_between(adv_trains, mean_upb, mean_downb, alpha=0.5, color='red', label=f"{name_2}")

    plt.legend(loc="upper right")

    plt.xlabel("Ball sizes")
    plt.ylabel("Entropy")

    plt.savefig(f"tmp/{attack_name}-{name}-entropy.png")
    plt.clf()

    stds = np.std(params_data[3], axis=1)
    means = np.mean(params_data[3], axis=1)

    stdsb = np.std(params_data_1[3], axis=1)
    meansb = np.mean(params_data_1[3], axis=1)

    mean_up = means + stds
    mean_down = means - stds

    mean_upb = meansb + stdsb
    mean_downb = meansb - stdsb

    plt.plot(adv_trains, means, color='blue')
    plt.plot(adv_trains, meansb, color='red')
    plt.fill_between(adv_trains, mean_up, mean_down, alpha=0.5, color='blue', label=f"{name_1}")
    plt.fill_between(adv_trains, mean_upb, mean_downb, alpha=0.5, color='red', label=f"{name_2}")

    plt.legend(loc="upper right")

    plt.xlabel("Ball sizes")
    plt.ylabel("Entropy")

    plt.savefig(f"tmp/{attack_name}-{name}-entropy-max.png")
    plt.clf()

    # =========================================

    stds = np.std(params_data[4], axis=1)
    means = np.mean(params_data[4], axis=1)

    stdsb = np.std(params_data_1[4], axis=1)
    meansb = np.mean(params_data_1[4], axis=1)

    mean_up = means + stds
    mean_down = means - stds

    mean_upb = meansb + stdsb
    mean_downb = meansb - stdsb

    plt.plot(adv_trains, means, color='blue')
    plt.plot(adv_trains, meansb, color='red')
    plt.fill_between(adv_trains, mean_up, mean_down, alpha=0.5, color='blue', label=f"{name_1}")
    plt.fill_between(adv_trains, mean_upb, mean_downb, alpha=0.5, color='red', label=f"{name_2}")

    plt.legend(loc="upper right")

    plt.xlabel("Ball sizes")
    plt.ylabel("Wasserstein distance")

    plt.savefig(f"tmp/{attack_name}-{name}-wd2.png")
    plt.clf()

    stds = np.std(params_data[5], axis=1)
    means = np.mean(params_data[5], axis=1)

    stdsb = np.std(params_data_1[5], axis=1)
    meansb = np.mean(params_data_1[5], axis=1)

    mean_up = means + stds
    mean_down = means - stds

    mean_upb = meansb + stdsb
    mean_downb = meansb - stdsb

    plt.plot(adv_trains, means, color='blue')
    plt.plot(adv_trains, meansb, color='red')
    plt.fill_between(adv_trains, mean_up, mean_down, alpha=0.5, color='blue', label=f"{name_1}")
    plt.fill_between(adv_trains, mean_upb, mean_downb, alpha=0.5, color='red', label=f"{name_2}")

    plt.legend(loc="upper right")

    plt.xlabel("Ball sizes")
    plt.ylabel("Wasserstein distance")

    plt.savefig(f"tmp/{attack_name}-{name}-wd2-min.png")
    plt.clf()






